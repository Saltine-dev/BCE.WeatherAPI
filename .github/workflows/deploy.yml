name: Deploy Weather API to AWS

on:
  push:
    branches:
      - main
      - develop
    paths-ignore:
      - README.md
  pull_request:
    branches:
      - main
    paths-ignore:
      - README.md
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod

env:
  AWS_REGION: us-east-1
  PYTHON_VERSION: '3.11'

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Cache pip dependencies
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements*.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pytest pytest-cov pytest-mock boto3 moto requests-mock
          pip install -r src/lambdas/weather_collector/requirements.txt
          pip install -r src/lambdas/weather_api/requirements.txt
      
      - name: Run unit tests
        run: |
          pytest tests/unit/ -v --cov=src --cov-report=xml --cov-report=term
      
      - name: Upload coverage reports
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage.xml
          flags: unittests
          name: codecov-umbrella
        if: github.event_name == 'push'

  validate-cloudformation:
    name: Validate CloudFormation Template
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Validate CloudFormation template
        run: |
          aws cloudformation validate-template \
            --template-body file://templates/weather-api-stack.yaml \
            --region ${{ env.AWS_REGION }}

  build:
    name: Build Lambda Packages
    runs-on: ubuntu-latest
    needs: [test, validate-cloudformation]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Create deployment packages
        run: |
          # Create build directory
          mkdir -p build/lambdas
          
          # Package Weather Collector Lambda
          echo "Packaging Weather Collector Lambda..."
          cd src/lambdas/weather_collector
          pip install -r requirements.txt -t .
          zip -r ../../../build/lambdas/weather-collector.zip . -x "*.pyc" -x "__pycache__/*"
          cd ../../../
          
          # Package Weather API Lambda
          echo "Packaging Weather API Lambda..."
          cd src/lambdas/weather_api
          pip install -r requirements.txt -t .
          zip -r ../../../build/lambdas/weather-api.zip . -x "*.pyc" -x "__pycache__/*"
          cd ../../../
          
          # Create common dependencies layer
          echo "Creating common dependencies layer..."
          mkdir -p build/layers/python
          pip install requests boto3 -t build/layers/python/
          cd build/layers
          zip -r ../common-dependencies.zip python -x "*.pyc" -x "__pycache__/*"
          cd ../../
      
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: lambda-packages
          path: build/
          retention-days: 7

  deploy:
    name: Deploy to AWS
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    
    strategy:
      matrix:
        environment: ${{ github.event_name == 'workflow_dispatch' && fromJSON(format('["{0}"]', github.event.inputs.environment)) || (github.ref == 'refs/heads/main' && fromJSON('["prod"]') || fromJSON('["dev"]')) }}
    
    environment:
      name: ${{ matrix.environment }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: lambda-packages
          path: build/
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Create S3 deployment bucket if not exists
        run: |
          BUCKET_NAME="weather-aggregator-${{ matrix.environment }}-deployment-${{ secrets.AWS_ACCOUNT_ID }}"
          
          if ! aws s3 ls "s3://${BUCKET_NAME}" 2>/dev/null; then
            echo "Creating S3 bucket: ${BUCKET_NAME}"
            aws s3 mb "s3://${BUCKET_NAME}" --region ${{ env.AWS_REGION }}
            aws s3api put-bucket-versioning \
              --bucket "${BUCKET_NAME}" \
              --versioning-configuration Status=Enabled
            aws s3api put-public-access-block \
              --bucket "${BUCKET_NAME}" \
              --public-access-block-configuration \
              "BlockPublicAcls=true,IgnorePublicAcls=true,BlockPublicPolicy=true,RestrictPublicBuckets=true"
          else
            echo "S3 bucket already exists: ${BUCKET_NAME}"
          fi
      
      - name: Upload Lambda packages to S3
        run: |
          BUCKET_NAME="weather-aggregator-${{ matrix.environment }}-deployment-${{ secrets.AWS_ACCOUNT_ID }}"
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          
          # Upload Lambda packages
          aws s3 cp build/lambdas/weather-collector.zip \
            "s3://${BUCKET_NAME}/lambdas/weather-collector-${TIMESTAMP}.zip"
          aws s3 cp build/lambdas/weather-api.zip \
            "s3://${BUCKET_NAME}/lambdas/weather-api-${TIMESTAMP}.zip"
          
          # Upload layer
          aws s3 cp build/common-dependencies.zip \
            "s3://${BUCKET_NAME}/layers/common-dependencies-${TIMESTAMP}.zip"
          
          # Create latest copies
          aws s3 cp "s3://${BUCKET_NAME}/lambdas/weather-collector-${TIMESTAMP}.zip" \
            "s3://${BUCKET_NAME}/lambdas/weather-collector.zip"
          aws s3 cp "s3://${BUCKET_NAME}/lambdas/weather-api-${TIMESTAMP}.zip" \
            "s3://${BUCKET_NAME}/lambdas/weather-api.zip"
          aws s3 cp "s3://${BUCKET_NAME}/layers/common-dependencies-${TIMESTAMP}.zip" \
            "s3://${BUCKET_NAME}/layers/common-dependencies.zip"
      
      - name: Deploy CloudFormation Stack
        run: |
          STACK_NAME="weather-aggregator-${{ matrix.environment }}"
          BUCKET_NAME="weather-aggregator-${{ matrix.environment }}-deployment-${{ secrets.AWS_ACCOUNT_ID }}"
          COLLECTOR_KEY="lambdas/weather-collector.zip"
          API_KEY="lambdas/weather-api.zip"
          LAYER_KEY="layers/common-dependencies.zip"
          
          # Determine stack action, and handle ROLLBACK_COMPLETE by deleting first
          STATUS=$(aws cloudformation describe-stacks \
            --stack-name "${STACK_NAME}" \
            --query "Stacks[0].StackStatus" \
            --output text 2>/dev/null || echo "NONE")

          if [ "$STATUS" = "ROLLBACK_COMPLETE" ] || [ "$STATUS" = "ROLLBACK_FAILED" ]; then
            echo "Stack is in $STATUS. Deleting before recreate..."
            aws cloudformation delete-stack --stack-name "${STACK_NAME}"
            aws cloudformation wait stack-delete-complete --stack-name "${STACK_NAME}"
            STACK_ACTION="create-stack"
            WAIT_ACTION="stack-create-complete"
          elif aws cloudformation describe-stacks --stack-name "${STACK_NAME}" >/dev/null 2>&1; then
            STACK_ACTION="update-stack"
            WAIT_ACTION="stack-update-complete"
          else
            STACK_ACTION="create-stack"
            WAIT_ACTION="stack-create-complete"
          fi
          
          # Deploy stack
          aws cloudformation ${STACK_ACTION} \
            --stack-name "${STACK_NAME}" \
            --template-body file://templates/weather-api-stack.yaml \
            --parameters \
              ParameterKey=Environment,ParameterValue=${{ matrix.environment }} \
              ParameterKey=ApiName,ParameterValue=weather-aggregator \
              ParameterKey=DataRetentionDays,ParameterValue=30 \
              ParameterKey=Location,ParameterValue=lewisville-tx \
              ParameterKey=Latitude,ParameterValue=33.0462 \
              ParameterKey=Longitude,ParameterValue=-96.9942 \
              ParameterKey=DeploymentBucketName,ParameterValue=${BUCKET_NAME} \
              ParameterKey=CollectorPackageKey,ParameterValue=${COLLECTOR_KEY} \
              ParameterKey=ApiPackageKey,ParameterValue=${API_KEY} \
              ParameterKey=UseCommonLayer,ParameterValue=true \
              ParameterKey=CommonLayerKey,ParameterValue=${LAYER_KEY} \
            --capabilities CAPABILITY_NAMED_IAM CAPABILITY_AUTO_EXPAND \
            --tags \
              Key=Environment,Value=${{ matrix.environment }} \
              Key=Application,Value=weather-aggregator \
              Key=ManagedBy,Value=CloudFormation \
              Key=Repository,Value=${{ github.repository }} \
            || true
          
          # Wait for stack to complete
          echo "Waiting for stack operation to complete..."
          aws cloudformation wait ${WAIT_ACTION} --stack-name "${STACK_NAME}" || {
            echo "Stack operation failed or timed out"
            aws cloudformation describe-stack-events \
              --stack-name "${STACK_NAME}" \
              --query 'StackEvents[?ResourceStatus==`CREATE_FAILED` || ResourceStatus==`UPDATE_FAILED`].[LogicalResourceId,ResourceStatusReason]' \
              --output table
            exit 1
          }
      
      - name: Update Lambda function code
        run: |
          STACK_NAME="weather-aggregator-${{ matrix.environment }}"
          BUCKET_NAME="weather-aggregator-${{ matrix.environment }}-deployment-${{ secrets.AWS_ACCOUNT_ID }}"
          
          # Get Lambda function names from stack outputs
          COLLECTOR_FUNCTION=$(aws cloudformation describe-stacks \
            --stack-name "${STACK_NAME}" \
            --query "Stacks[0].Outputs[?OutputKey=='WeatherCollectorFunctionArn'].OutputValue" \
            --output text | awk -F: '{print $NF}')
          
          API_FUNCTION=$(aws cloudformation describe-stacks \
            --stack-name "${STACK_NAME}" \
            --query "Stacks[0].Outputs[?OutputKey=='WeatherAPIFunctionArn'].OutputValue" \
            --output text | awk -F: '{print $NF}')
          
          # Update Lambda function code
          echo "Updating Weather Collector Lambda function..."
          aws lambda update-function-code \
            --function-name "${COLLECTOR_FUNCTION}" \
            --s3-bucket "${BUCKET_NAME}" \
            --s3-key "lambdas/weather-collector.zip" \
            --publish
          
          echo "Updating Weather API Lambda function..."
          aws lambda update-function-code \
            --function-name "${API_FUNCTION}" \
            --s3-bucket "${BUCKET_NAME}" \
            --s3-key "lambdas/weather-api.zip" \
            --publish
      
      - name: Run integration tests
        run: |
          STACK_NAME="weather-aggregator-${{ matrix.environment }}"
          
          # Get API endpoint from stack outputs
          API_ENDPOINT=$(aws cloudformation describe-stacks \
            --stack-name "${STACK_NAME}" \
            --query "Stacks[0].Outputs[?OutputKey=='ApiEndpoint'].OutputValue" \
            --output text)
          
          echo "API Endpoint: ${API_ENDPOINT}"
          
          # Test health endpoint
          echo "Testing health endpoint..."
          HEALTH_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" "${API_ENDPOINT}/health")
          if [ "${HEALTH_RESPONSE}" -eq 200 ]; then
            echo "✅ Health check passed"
          else
            echo "❌ Health check failed with status: ${HEALTH_RESPONSE}"
            exit 1
          fi
          
          # Test sources endpoint
          echo "Testing sources endpoint..."
          SOURCES_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" "${API_ENDPOINT}/weather/sources")
          if [ "${SOURCES_RESPONSE}" -eq 200 ]; then
            echo "✅ Sources endpoint passed"
          else
            echo "❌ Sources endpoint failed with status: ${SOURCES_RESPONSE}"
            exit 1
          fi
      
      - name: Output deployment information
        run: |
          STACK_NAME="weather-aggregator-${{ matrix.environment }}"
          
          echo "======================================"
          echo "Deployment Complete!"
          echo "======================================"
          echo ""
          echo "Stack Name: ${STACK_NAME}"
          echo "Environment: ${{ matrix.environment }}"
          echo ""
          echo "Stack Outputs:"
          aws cloudformation describe-stacks \
            --stack-name "${STACK_NAME}" \
            --query "Stacks[0].Outputs[*].[OutputKey,OutputValue]" \
            --output table

  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: deploy
    if: always()
    
    steps:
      - name: Send deployment notification
        run: |
          if [ "${{ needs.deploy.result }}" == "success" ]; then
            echo "✅ Deployment successful!"
          else
            echo "❌ Deployment failed!"
          fi
